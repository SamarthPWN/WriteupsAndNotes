# ‎ 

**File:** [txt](./txt)

## Given File Content:
```
   			 		 
	
      		   	
	
     			 	  
	
     				 		
	
      		   	
	
     	 					
	
     		   		
	
      		 	  
	
     		 			 
	
     			 	  
	
     	 					
	
     			  		
	
      		  		
	
      		  		
	
     	 					
	
      		 	  
	
     		 			 
	
     				  	
	
     			 	  
	
     		 	   
	
      		   	
	
     		 			 
	
     		  			
	
     					 	
	
  




```

## Writeup:
When I first opened the given file named, it appeared completely empty. The challenge title immediately hinted that there was something hidden in plain sight so I decided to check its properties using the terminal. Running `ls -l txt` and `wc -c txt` showed that the file had a size of 416 bytes, confirming that it wasn’t actually empty. This suggested that the contents were probably invisible or non-printable characters. To view what was truly inside, I used the command `sed -n l txt`, which displays non-printable characters like tabs and carriage returns in a visible form. The output was full of `spaces` and `\t (tabs)` spread across multiple lines, which instantly stood out as a clue that the data might be encoded using whitespace.  
Recognizing this as a common CTF trick, I recalled that `spaces` and `tabs` are often used to represent binary data, where a `space` stands for `0` and a `tab` stands for `1`. Each line essentially represented a sequence of binary digits hidden inside the invisible whitespace. I then decided to convert these invisible characters into binary by replacing all `tabs` with `1` and `spaces` with `0`, stripping away the extra carriage returns. After that, I grouped the resulting binary string into chunks of 8 bits each, converting every group into its corresponding ASCII character. This revealed readable text that slowly started forming a meaningful string.  
To make the decoding process faster and reproducible, I wrote a short Python script that performed the conversion automatically. The script reads the file, replaces each `tab` with a `1` and each `space` with a `0`, removes other unnecessary characters and finally converts the binary data into readable text.
```python
data = open("txt", "r").read()
binary = ""

for ch in data:
    if ch == "\t":
        binary += "1"
    elif ch == " ":
        binary += "0"

flag = ''.join(chr(int(binary[i:i+8], 2)) for i in range(0, len(binary), 8))

print(flag)
```
Running this revealed the flag.

## Flag:
```text
v1t{1_c4nt_s33_4nyth1ng}
```
